<article>
    <h2>Dominando as Fun√ß√µes Nativas do JavaScript</h2>
    
    <p>Neste tutorial, voc√™ aprender√° sobre as fun√ß√µes nativas mais √∫teis do JavaScript e como elas podem tornar seu c√≥digo mais eficiente e elegante. Vamos explorar desde manipula√ß√£o de strings at√© opera√ß√µes matem√°ticas avan√ßadas.</p>
  
    <section>
      <h2>Manipula√ß√£o de Strings</h2>
      <p>O JavaScript oferece uma rica cole√ß√£o de m√©todos para trabalhar com texto. Vamos explorar os mais √∫teis:</p>
  
      <div class="code-block">
        <p>üìÑ string-methods.js</p>
        <pre><code>
  // Transforma√ß√£o de caso
  const texto = "JavaScript √© Incr√≠vel";
  console.log(texto.toLowerCase());  // javascript √© incr√≠vel
  console.log(texto.toUpperCase());  // JAVASCRIPT √â INCR√çVEL
  
  // Busca e substitui√ß√£o
  const frase = "O gato e o rato";
  console.log(frase.includes('rato'));     // true
  console.log(frase.replace('rato', 'c√£o')); // O gato e o c√£o
  
  // Remo√ß√£o de espa√ßos
  const espacado = "  trim me  ";
  console.log(espacado.trim());  // "trim me"</code></pre>
      </div>
    </section>
  
    <section>
      <h2>Opera√ß√µes Matem√°ticas</h2>
      <p>O objeto Math fornece m√©todos poderosos para c√°lculos matem√°ticos:</p>
  
      <div class="code-block">
        <p>üìÑ math-operations.js</p>
        <pre><code>
  // Arredondamento
  console.log(Math.round(3.6));    // 4
  console.log(Math.floor(3.6));    // 3
  console.log(Math.ceil(3.2));     // 4
  
  // Valores m√≠nimos e m√°ximos
  console.log(Math.min(5, 2, 9));  // 2
  console.log(Math.max(5, 2, 9));  // 9
  
  // N√∫meros aleat√≥rios
  console.log(Math.random());      // n√∫mero entre 0 e 1
  // N√∫mero aleat√≥rio entre 1 e 10
  console.log(Math.floor(Math.random() * 10) + 1);</code></pre>
      </div>
    </section>
  
    <section>
      <h2>Manipula√ß√£o de Arrays</h2>
      <p>Arrays possuem m√©todos poderosos para transforma√ß√£o e busca de dados:</p>
  
      <div class="code-block">
        <p>üìÑ array-methods.js</p>
        <pre><code>
  const numeros = [1, 2, 3, 4, 5];
  
  // Transforma√ß√£o
  const dobrados = numeros.map(n => n * 2);
  console.log(dobrados);  // [2, 4, 6, 8, 10]
  
  // Filtragem
  const pares = numeros.filter(n => n % 2 === 0);
  console.log(pares);  // [2, 4]
  
  // Redu√ß√£o
  const soma = numeros.reduce((acc, n) => acc + n, 0);
  console.log(soma);  // 15</code></pre>
      </div>
    </section>
  
    <section class="challenge-section">
      <h2>Desafio Pr√°tico</h2>
      <p>Crie uma fun√ß√£o que processe uma lista de produtos:</p>
      
      <ul>
        <li>Receba um array de objetos com nome e pre√ßo dos produtos</li>
        <li>Filtre apenas produtos com pre√ßo maior que R$ 50</li>
        <li>Aplique 10% de desconto em todos os pre√ßos</li>
        <li>Retorne o valor total da compra</li>
      </ul>
  
      <div class="code-block">
        <p>üìÑ challenge.js</p>
        <pre><code>
  const produtos = [
    { nome: 'T√™nis', preco: 120 },
    { nome: 'Camiseta', preco: 40 },
    { nome: 'Cal√ßa', preco: 80 }
  ];
  
  function processarCompra(produtos) {
    return produtos
      .filter(p => p.preco > 50)
      .map(p => ({ ...p, preco: p.preco * 0.9 }))
      .reduce((total, p) => total + p.preco, 0);
  }
  
  console.log(processarCompra(produtos));</code></pre>
      </div>
    </section>
  
    <section>
      <h2>Dicas e Melhores Pr√°ticas</h2>
      <ul>
        <li>Sempre verifique se o m√©todo que voc√™ precisa j√° existe como fun√ß√£o nativa antes de implementar manualmente</li>
        <li>Consulte a documenta√ß√£o MDN para entender todos os par√¢metros dispon√≠veis</li>
        <li>Use m√©todos de array encadeados para opera√ß√µes complexas, mas mantenha a legibilidade</li>
        <li>Prefira m√©todos imut√°veis (que n√£o modificam o array original) para c√≥digo mais previs√≠vel</li>
      </ul>
    </section>
  
    <section>
      <h2>Perguntas Frequentes</h2>
      
      <details>
        <summary>Por que usar fun√ß√µes nativas em vez de implementar manualmente?</summary>
        <p>Fun√ß√µes nativas s√£o otimizadas, testadas extensivamente e geralmente mais r√°pidas que implementa√ß√µes manuais. Al√©m disso, tornam o c√≥digo mais leg√≠vel e padronizado.</p>
      </details>
  
      <details>
        <summary>Como descobrir quais m√©todos est√£o dispon√≠veis para cada tipo de dado?</summary>
        <p>Voc√™ pode consultar a documenta√ß√£o MDN ou usar o console do navegador. Digite o valor seguido de ponto (exemplo: "string".} para ver todos os m√©todos dispon√≠veis.</p>
      </details>
  
      <details>
        <summary>Os m√©todos de array modificam o array original?</summary>
        <p>Alguns m√©todos como push(), pop(), splice() modificam o array original. Outros como map(), filter(), reduce() criam um novo array. Consulte a documenta√ß√£o para cada m√©todo espec√≠fico.</p>
      </details>
    </section>
  </article>